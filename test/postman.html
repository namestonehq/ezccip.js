<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CCIP-Read Postman</title>
<style>
.hide { display: none !important; }
.invis { visibility: hidden !important; }
body {
	margin: 3rem;
	background: #eee;
}
button {
	appearance: none;
	display: inline-flex;
	align-items: center;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid #888;
	border-radius: 4px;
	background-color: #eee;
	color: #000;
	font-size: 90%;
	gap: 4px;
	transition: transform .1s ease;
}
button:disabled {
	opacity: .5;
	pointer-events: none;
}
button:hover {
	transform: scale(1.04);
	border: 2px solid #000;
	margin: -1px;
}
button:hover:active {
	transform: unset;
}
button:not(:disabled) {	
	cursor: pointer;
}
button.icon {
	padding: 8px;
}
button.copy {
	flex: 0 0 auto;
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
	background-size: 85%;	
}
button.copy:hover {
	opacity: 1;
	background-color: #8f8;
	transform: none;
	margin: 0;
}
button.copy.copied {
	opacity: 1;
	background-color: #8f8;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
#add_batch_btn,
#add_field_btn {
	background-color: #efe;
}
#mod_fields {
	flex-wrap: wrap;
}
#mod_fields label {
	display: flex;
	align-items: center;
	gap: 4px;
	user-select: none;
}
#mod_fields label span {
	white-space: pre;
}
/* #mod_fields button { align-self: stretch; } */
.delete_btn {
	background-color: #fee;
	align-self: stretch;
}
select {
	padding: 4px 8px;
	font-size: 100%;
	cursor: pointer;
}
input.code {
	font: 120% monospace;
}
header {
	display: flex;
	justify-content: space-between;
}
h1 {
	margin: 0;
}
#examples {
	margin: 8px 0;
	display: flex;
	gap: 8px;
	flex-wrap: wrap;
	align-items: center;
	padding-bottom: 8px;
	border-bottom: 2px solid #fff;
}
#examples code {
	background-color: #fff;
	padding: 2px 4px;
	border: 1px solid #ccc;
}
.rows {
	display: flex;
	flex-direction: column;
	gap: 8px;
}
.row {
	display: flex;
	align-items: center;
	gap: 8px;
}
.header {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
	margin-bottom: 8px;
}
.header button:first-of-type {
	margin-left: auto;
}
.header i::before {
	content: '‚ö†Ô∏è';
	position: relative;
	margin-right: 2px;
	font-style: normal;
	font-size: 95%;
}
.header i:empty { display: none; }
.header i {
	opacity: .7;
}
#options {
	border-top: 2px solid #fff;
	padding-top: 8px;
}
#func_select {
	width: 100%;
	font-size: 130%;
}
input, textarea {
	display: block;
	width: 100%;
	box-sizing: border-box;
	padding: 8px;
	font-size: 130%;
}
textarea {
	resize: vertical;
	min-height: 40px;
}
#endpoint_field,
.endpoints_field {
	color: #00c;
}
#method_span:empty { display: none; }
#method_span {
	padding: 3px 6px;
	border-radius: 4px;
	background-color: #afa;
	border: 1px solid #aaa;
	font: 12px sans-serif;
}
#abi_span:empty { display: none; }
#abi_span {
	padding: 3px 6px;
	border-radius: 4px;
	background-color: #cff;
	border: 1px solid #aaa;
	font-family: monospace;
}
.field {
	display: flex;
	flex-wrap: wrap;
	gap: 8px;
	align-items: center;
}
.field input {
	padding: 4px;
	flex: 1;
}
#ensip10 .field {
	align-items: stretch;
}
.field label {
	flex: 0 0 25%;
	display: flex;
	flex-direction: column;
	gap: 2px;
	text-align: right;
}
#urg_verifier_field {
	font: 12px monospace;
	width: 50ch;
	padding: 4px;
}
#batch .field + .field {
	border-top: 2px solid #fff;
	padding-top: 8px;
}
#batch .endpoints_field {
	font-size: 12px;
	flex: 100%;
}
.field label span.name {
	font-weight: bold;
	line-break: anywhere;
}
.field label span.type {
	font: 11px monospace;
	opacity: .7;
}
.field textarea {
	display: flex;
	flex: 100%;
}
.type_select, .arg_field {
	font: 12px monospace;
}
.suggest_select {
	width: 30px;
}
#field_count_lbl {
	font-weight: bold;
}
#actions button {
	padding: 8px;
	font-size: 100%;
	align-self: stretch;
}
#start_btn {
	font-weight: bold;
	background-color: #afa;
}
#start_btn.unsupported {
	font-weight: unset;
	background-color: #ffc;
}
#start_btn.unsupported::after {
	content: ' Unsupported';
}
#stop_btn {
	background-color: #faa;
}
.spinner {
	width: 24px;
	height: 24px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 4px solid #000;
	border-bottom-color: transparent;
	border-radius: 100%;
}
#output:empty { display: none; }
#output {
	margin-top: 8px;
	border-top: 2px solid #fff;
	padding-top: 8px;
}
#output > pre {
	margin: 0;
	border: 1px solid #ccc;
	padding: 8px;
	background-color: #fff;
	font: 13px monospace;
	white-space: pre-wrap;
	line-break: anywhere;
	overflow-y: auto;
}
#output pre + pre {
	margin-top: 4px;
}
#output pre.clipped {	
	max-height: 150px;
}
#output .log {
	padding: 4px;
	display: flex;
	gap: 8px;
	align-items: center;
}
#output .log + .log {
	border-top: 1px solid #fff;
}
#output .time {
	opacity: .5;
	font: 11px sans-serif;
	flex: 0 0 60px;
	text-align: right;
}
#output .tags {
	display: flex;
	gap: 4px;
	align-items: center;
	flex-wrap: wrap;
}
#output .tag {
	padding: 4px 8px;
	display: flex;
	align-items: center;
	gap: 6px;
	background-color: #fff;
	border-radius: 4px;
	border: 1px solid #ccc;
	font: 14px sans-serif;
	word-break: break-word;
}
#output .tag.code {
	font: 14px monospace;
}
#output .tag.addr { background-color: #f8eeff;}
#output .tag.hash { 
	background-color: #eff; 
	font-size: 12px;
}
#output .tag.http { background-color: #def; }
#output .tag.primary {
	font: bold 12px sans-serif;
	background-color: #ffc;
}
#output .tag.dns {
	font: bold 12px monospace;
	background-color: #cff;
}
#output .tag.record {
	border: none;
	font: 11px monospace;
	background-color: #c4c4;
}
#output .record[data-name="text"] { background-color: #66f4; }
#output .record[data-name="data"] { background-color: #a804; }
#output .record[data-name="addr"] { background-color: #0a84; }
#output .tag .copy {
	width: 20px;
	height: 20px;
	margin-right: -4px;
}
#output .log.success { 
	background: linear-gradient(90deg, #0000, #cfc, #0000);
}
#output .log.error {
	background: linear-gradient(90deg, #0000, #fcc, #0000);
}
#output .log.error + pre {
	background-color: #fee;
}
#output .tag.size {
	background-color: #f8eedd;
	font: 11px sans-serif;
}
#output .tag .key {
	opacity: .5;
	user-select: none;
	font: 11px sans-serif;
	white-space: pre;
}
#output .tag .value.null {
	opacity: .7;
	font-size: 80%;
	user-select: none;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#profile_dialog {
	width: 80vw;
	background-color: #eee;
	border-radius: 8px;
	border: 2px solid #000;
 	box-shadow: 0 0 8px #0008;
	/* display: flex;
	gap: 16px;
	align-items: center */
}
#profile_dialog .row {
	margin-top: 16px;
}
#profile_dialog i {
	color: #666;
}
#profile_dialog code {
	font-family: monospace;
	background-color: #cff;	
}
#profile_dialog::backdrop {
	backdrop-filter: blur(2px);
}
footer {
	text-align: center;
	color: #666;
	margin: 16px;
}
@media only screen and (max-width: 800px) { 
	body {
		margin: 1rem;
	}
	#multi_select {
		order: 1;
		flex: 100%;
	}
}
@media only screen and (max-width: 500px) {	
	h1 a {
		display: none;
	}
}
</style>
</head>
<body>
<dialog id="profile_dialog">
	<textarea id="profile_ta" rows="16" autofocus></textarea>
	<div class="row">
		<i>Accepts <code>json</code> or <code>[\s,]</code>-separated input.</i>
		<button id="profile_save_btn" style="margin-left: auto">üìùÔ∏è Update</button>
	</div>
</dialog>
<header>
	<h1><a target="_blank" href="https://eips.ethereum.org/EIPS/eip-3668">CCIP-Read</a> Postman</h1>
	<a target="_blank" href="https://github.com/namestonehq/ezccip.js">namestonehq/ezccip.js</a>
</header>
<div id="examples">
	<b> Examples:</b>
	<button data-config='{
		"endpoint":"https://raffy.xyz/ezccip/",
		"proto":"tor",
		"name":"raffy.eth",
		"fields":[
			{"type":"text", "arg": "location"},
			{"type":"text", "arg": "name"},
			{"type":"text", "arg": "notice"},
			{"type":"text", "arg": "description"},
			{"type":"data", "arg": "test"},
			{"type":"addr", "arg": "$eth"},
			{"type":"addr", "arg": "$doge"},
			{"type":"pubkey"},
			{"type":"chash"}
		]
	}'>TOR</button>
	<button data-config='{
		"endpoint":"https://raffy.xyz/ezccip/0x3CA097Edd180Ea2C2436BD30c021Ca20869087a0",
		"sender": "0x3CA097Edd180Ea2C2436BD30c021Ca20869087a0",
		"proto": "ens",
		"name":"raffy.eth",
		"fields":[
			{"type":"text", "arg": "location"},
			{"type": "addr", "arg": "$eth"}
		]
	}'>ENS</button>
	<button data-config='{
		"endpoint": "https://raffy.xyz/ezccip/",
		"proto":"tor",
		"abi": "function example(uint256 a, uint256 b) returns (uint256 c)",
		"args": ["69", "420"]
	}'>ABI: Plus()</button>
	<button data-config='{
		"endpoint": "https://raffy.xyz/tog/raffyeth/",
		"proto":"tor",
		"name": "raffy.eth",
		"fields": [{"type":"text", "arg": "description"}, {"type":"text", "arg": "location"}]
	}'>TOG &rarr; <code>raffy.eth</code></button>
	<button data-config='{
		"dns":"antistupid.com"
	}'>DNSSEC &rarr; <code>antistupid.com</code></button>
	<button data-config='{
		"batches": [{
			"address": "0x84c5AdB77dd9f362A1a3480009992d8d47325dc3",
			"endpoints": ["https://raffy.xyz/tog/raffyeth/e1"],
			"calldata": "0x9061b92300000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b057261666679036574680000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000243b3b57de9c8b7ac505c9f0161bbbd04437fce8c630a0886e1ffea00078e298f063a8a5df00000000000000000000000000000000000000000000000000000000"
		}]
	}'>Batch &rarr; TOR &rarr; TOG &rarr; <code>raffy.eth</code></button>
	<button data-config='{
		"endpoint": "https://arbitrum.3668.io",
		"request": "0x010fd8e504002cc26e3ec46d81971c16643200461451050ec063d393217b436747617ad1c2285aeeee483d003300000000000000000000000000000000000000"
	}'>Arbitrum Primary &rarr; <code>5105.8000a4b1.reverse</code></button>
</div>
<main>
<div id="config" class="rows">
	<div>
		<div class="header buttoned">
			<label for="endpoint_field">Endpoint</label>
			<span id="method_span"></span>
			<i id="endpoint_status"></i>
			<button id="endpoint_btn" disabled>‚ÜóÔ∏è Visit</button>
		</div>
		<input class="big" id="endpoint_field">
	</div>
	<div>
		<div class="header">
			<label for="sender_field">Sender</label>
			<i id="sender_status"></i>
		</div>
		<input id="sender_field" class="code" placeholder="0x0000000000000000000000000000000000000000">
	</div>
	<div id="proto">
		<label for="proto_select">Protocol:</label>
		<select id="proto_select">
			<option value="raw">Raw</option>
			<option value="ens">ENS</option>
			<option value="tor">TOR</option>
		</select>
		<!-- <input id="signer_field" class="code" placeholder="0x0000000000000000000000000000000000000000"> -->
	</div>
	<div id="options">
		<select id="func_select">
			<optgroup label="Application">
				<option value="ensip10">ENSIP-10: resolve(name, ...)</option>
				<option value="dns">DNSSEC Oracle: resolve(name, dnstype)</option>
				<option value="urg">Unruggable Gateway: proveRequest(request)</option>
				<option value="batch">Batch Gateway: query(request[])</option>
			</group>
			<optgroup label="Protocol">
				<option value="abi">Function ABI</option>
				<option value="calldata">Raw Calldata</option>	
			</optgroup>
		</select>
	</div>
	<div id="ensip10" class="rows hide">
		<div>
			<div class="header">
				<label for="name_field">ENS Name</label>
				<i id="name_status"></i>
				<button id="to_batch_btn">Convert to Batch</button>
				<button id="resolve_btn" disabled>‚Ü©Ô∏è Resolve</button>
			</div>
			<input class="big" id="name_field" placeholder="raffy.eth">
		</div>
		<div id="mod_fields" class="row">
			<button id="add_field_btn" title="[ALT] Add Default Profile">‚úèÔ∏è Add Field</button>
			<button id="delete_all_fields_btn" class="hide delete_btn">
				<svg height="16" stroke-linejoin="round" style="color: currentcolor;" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" clip-rule="evenodd" d="M6.75 2.75C6.75 2.05964 7.30964 1.5 8 1.5C8.69036 1.5 9.25 2.05964 9.25 2.75V3H6.75V2.75ZM5.25 3V2.75C5.25 1.23122 6.48122 0 8 0C9.51878 0 10.75 1.23122 10.75 2.75V3H12.9201H14.25H15V4.5H14.25H13.8846L13.1776 13.6917C13.0774 14.9942 11.9913 16 10.6849 16H5.31508C4.00874 16 2.92263 14.9942 2.82244 13.6917L2.11538 4.5H1.75H1V3H1.75H3.07988H5.25ZM4.31802 13.5767L3.61982 4.5H12.3802L11.682 13.5767C11.6419 14.0977 11.2075 14.5 10.6849 14.5H5.31508C4.79254 14.5 4.3581 14.0977 4.31802 13.5767Z" fill="currentColor"></path></svg>
				Reset
			</button>
			<span id="field_count_lbl">0 fields</span>
			<button id="edit_profile_btn" title="JSON&#10;[ALT] Text">üìùÔ∏è Edit as Profile</button>
			<label style="margin-left: auto">
				<input id="node_as_null_check" type="checkbox"><span>Null Node</span>
			</label>
			<select id="multi_select" class="hide">
				<option value="inner">resolve(name, multicall([...]))</option>
				<option value="outer">multicall([resolve(name, ...), ...])</option>
			</select>
		</div>
	</div>
	<div id="abi" class="rows hide">
		<div>
			<div class="header">
				<label for="abi_ta">ABI</label>
				<span id="abi_span"></span>
				<i id="abi_status"></i>
			</div>
			<textarea id="abi_ta" rows="2" placeholder="function f(uint256, uint256) view returns (uint256)"></textarea>
		</div>
	</div>
	<div id="calldata" class="rows hide">
		<div>
			<div class="header">
				<label for="calldata_ta">Calldata</label>
				<i id="calldata_status"></i>
				<button id="calldata_btn">üîçÔ∏è Lookup</button>
			</div>
			<textarea id="calldata_ta" rows="20" placeholder="0x12345678..."></textarea>
		</div>
	</div>
	<div id="batch" class="rows hide">
		<div class="row">
			<button id="add_batch_btn">‚úèÔ∏è Add Batch</button>
			<button id="delete_all_batches_btn" class="hide delete_btn">
				<svg height="16" stroke-linejoin="round" style="color: currentcolor;" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" clip-rule="evenodd" d="M6.75 2.75C6.75 2.05964 7.30964 1.5 8 1.5C8.69036 1.5 9.25 2.05964 9.25 2.75V3H6.75V2.75ZM5.25 3V2.75C5.25 1.23122 6.48122 0 8 0C9.51878 0 10.75 1.23122 10.75 2.75V3H12.9201H14.25H15V4.5H14.25H13.8846L13.1776 13.6917C13.0774 14.9942 11.9913 16 10.6849 16H5.31508C4.00874 16 2.92263 14.9942 2.82244 13.6917L2.11538 4.5H1.75H1V3H1.75H3.07988H5.25ZM4.31802 13.5767L3.61982 4.5H12.3802L11.682 13.5767C11.6419 14.0977 11.2075 14.5 10.6849 14.5H5.31508C4.79254 14.5 4.3581 14.0977 4.31802 13.5767Z" fill="currentColor"></path></svg>
				Reset
			</button>
		</div>
	</div>
	<div id="urg" class="rows hide">
		<div>
			<div class="header">
				<label for="urg_context_field">Context</label>
				<i id="urg_context_status"></i>
				<button id="urg_gateway_btn">From Gateway</button>
				<!--
				<button id="urg_verifier_btn">From Verifier:</button>
				<input id="urg_verifier_field" placeholder="Verifier Address">
				-->
			</div>
			<input class="code" id="urg_context_field" placeholder="0x">
		</div>
		<div>
			<div class="header">
				<label for="urg_ta">Request</label>
			</div>
			<textarea id="urg_ta" rows="8"></textarea>
		</div>
	</div>
	<div id="dns" class="rows hide">
		<div>
			<div class="header">
				<label for="dns_name_field">DNS Name</label>
				<i id="dns_name_status"></i>
			</div>
			<input class="big" id="dns_name_field" placeholder="raffy.xyz">
		</div>
	</div>
	<div id="actions" class="row">
		<div id="spinner" class="spinner hide"></div>
		<button id="copy_link_btn" style="margin-left: auto" title="Copy link that resolves on load">üîóÔ∏è Copy Link</button>
		<button id="make_calldata_btn" title="Show calldata for current operation">‚úèÔ∏è Calldata</button>
		<button id="to_calldata_btn" title="Convert to calldata">üîçÔ∏è Data</button>
		<button id="start_btn" disabled>‚ö°Ô∏è Call</button>
		<button id="stop_btn" class="hide">üõëÔ∏è Stop</button>
	</div>
</div>
<div id="output"></div>
</main>
<footer>
	<span>Created by <a href="https://x.com/adraffy">raffy.eth</a></span>
</footer>
<script type="module">
import {Coin, Record, Profile, dns_encoded} from '../../enson.js/dist/index.min.js';
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.min.js';

const JSON_INDENT = '    '; // \t

const STORAGE_KEY = 'ezccip.config';

const TEMPLATE_DATA = '{data}';
const TEMPLATE_SENDER = '{sender}';

const DEFAULT_PROTO = 'ens';

const TYPE_CHASH = 'chash';
const TYPE_TEXT = 'text';
const TYPE_DATA = 'data';
const TYPE_ADDR = 'addr';
const TYPE_NAME = 'name';
const TYPE_PUBKEY = 'pubkey';

const FUNC_ENSIP10 = 'ensip10';
const FUNC_ABI = 'abi';
const FUNC_CALLDATA = 'calldata';
const FUNC_BATCH = 'batch';
const FUNC_URG = 'urg';
const FUNC_DNS = 'dns';

const SUGGESTED_TEXT_KEYS = [...Profile.ENS().texts];
const SUGGESTED_COINS = [...Coin].filter(x => !x.unnamed && !x.legacy).sort((a, b) => a.type > b.type ? 1 : -1);

const ABI_CODER = ethers.AbiCoder.defaultAbiCoder();

const BYTES_OPS = [
	{name: 'Hex', encode: s => ethers.hexlify(ethers.toUtf8Bytes(s)) },
	{name: 'Keccak', encode: s => s.startsWith('0x') ? ethers.keccak256(s) : ethers.id(s) },
	{name: 'Namehash', encode: s => ethers.namehash(s) },
	{name: 'DNS Encoded', encode: s => ethers.hexlify(dns_encoded(s)) },
];

const BATCH_ABI = new ethers.Interface([
	'function query((address, string[], bytes)[] memory data) external view returns (bool[] memory failures, bytes[] memory responses)',
	'error HttpError((uint16 status, string message)[] errors)',
]);

const URG_ABI = new ethers.Interface([
	`function proveRequest(bytes context, (bytes)) view returns (bytes)`,
	`function getLatestContext() view returns (bytes)`,
]);

const DNS_ABI = new ethers.Interface([
	`function resolve(bytes memory name, uint16 qtype) returns ((bytes, bytes)[] memory rrs)`
]);

const RESOLVE_ABI = new ethers.Interface([
	"function resolve(bytes, bytes) view returns (bytes)",
	"function multicall(bytes[] calls) view returns (bytes[])",
	//
	"function name(bytes32 node) view returns (string)",
	"function addr(bytes32 node) view returns (address)",
	"function addr(bytes32 node, uint256 type) view returns (bytes)",
	"function hasAddr(bytes32 node, uint256 type) view returns (bool)",
	"function data(bytes32 node, string key) view returns (bytes)",
	"function text(bytes32 node, string key) view returns (string)",
	"function contenthash(bytes32 node) view returns (bytes)",
	"function pubkey(bytes32 node) view returns (uint256 x, uint256 y)",
	"function ABI(bytes32 node, uint256 types) view returns (uint256 type, bytes memory data)",
	//
	"error UnsupportedResolverProfile(bytes4 selector)",
	"error UnreachableName(bytes name)",
]);

const endpoint_field = document.getElementById('endpoint_field');
const method_span = document.getElementById('method_span');
const endpoint_status = document.getElementById('endpoint_status');
const endpoint_btn = document.getElementById('endpoint_btn');
const sender_field = document.getElementById('sender_field');
const sender_status = document.getElementById('sender_status');
const func_select = document.getElementById('func_select');
const start_btn = document.getElementById('start_btn');
const copy_link_btn = document.getElementById('copy_link_btn');
const stop_btn = document.getElementById('stop_btn');
const make_calldata_btn = document.getElementById('make_calldata_btn');
const to_calldata_btn = document.getElementById('to_calldata_btn');
const ensip10_div = document.getElementById('ensip10');
const name_field = document.getElementById('name_field');
const resolve_btn = document.getElementById('resolve_btn');
const to_batch_btn = document.getElementById('to_batch_btn');
const name_status = document.getElementById('name_status');
const abi_div = document.getElementById('abi');
const abi_ta = document.getElementById('abi_ta');
const abi_status = document.getElementById('abi_status');
const abi_span = document.getElementById('abi_span');
const calldata_div = document.getElementById('calldata');
const calldata_ta = document.getElementById('calldata_ta');
const calldata_btn = document.getElementById('calldata_btn');
const calldata_status = document.getElementById('calldata_status');
const main_spinner = document.querySelector('#actions .spinner');
const add_field_btn = document.getElementById('add_field_btn');
const delete_all_fields_btn = document.getElementById('delete_all_fields_btn');
const field_count_lbl = document.getElementById('field_count_lbl');
const batch_div = document.getElementById('batch');
const add_batch_btn = document.getElementById('add_batch_btn');
const delete_all_batches_btn = document.getElementById('delete_all_batches_btn');
const urg_div = document.getElementById('urg');
const urg_context_field = document.getElementById('urg_context_field');
const urg_context_status = document.getElementById('urg_context_status');
//const urg_verifier_field = document.getElementById('urg_verifier_field');
//const urg_verifier_btn = document.getElementById('urg_verifier_btn');
const urg_gateway_btn = document.getElementById('urg_gateway_btn');
const dns_div = document.getElementById('dns');
const dns_name_field = document.getElementById('dns_name_field');
const dns_name_status = document.getElementById('dns_name_status');
const urg_ta = document.getElementById('urg_ta');
const multi_select = document.getElementById('multi_select');
const proto_div = document.getElementById('proto');
const proto_select = document.getElementById('proto_select');
const output_div = document.getElementById('output');
const edit_profile_btn = document.getElementById('edit_profile_btn');
const profile_dialog = document.getElementById('profile_dialog');
const profile_ta = document.getElementById('profile_ta');
const profile_save_btn = document.getElementById('profile_save_btn');
const node_as_null_check = document.getElementById('node_as_null_check');

let start_time;
let aborter;
let update_timer;

let endpoint, sender, abi, abi_func;

const abi_fields = [];
endpoint_field.addEventListener('input', update_ux_soon);
sender_field.addEventListener('input', update_ux_soon);
name_field.addEventListener('input', update_ux_soon);
func_select.addEventListener('input', () => {
	focus_func();
	update_ux();
});
multi_select.addEventListener('input', update_ux);
node_as_null_check.addEventListener('input', update_ux);
abi_ta.addEventListener('input', update_ux_soon);
calldata_ta.addEventListener('input', update_ux_soon);
calldata_btn.addEventListener('click', () => visit(`https://www.4byte.directory/signatures/?bytes4_signature=${calldata_ta.value.trim().slice(0, 10)}`));
urg_context_field.addEventListener('input', update_ux);
//urg_verifier_field.addEventListener('input', update_ux);
urg_gateway_btn.addEventListener('click', async () => {
	urg_gateway_btn.disabled = true;
	try {
		const res = await fetch(new URL('./head', endpoint_field.value.trim()));
		if (!res.ok) {
			throw new Error(`HTTP ${res.status}`);
		}
		let {commitIndex} = await res.json();
		if (typeof commitIndex === 'object' && commitIndex.value) {
			commitIndex = commitIndex.value;
		}
		urg_context_field.value = commitIndex;
		update_ux();
	} catch (err) {
		window.alert(String(err));
	}
	urg_gateway_btn.disabled = false;
});
urg_ta.addEventListener('input', update_ux_soon);
dns_name_field.addEventListener('input', update_ux);
proto_select.addEventListener('input', update_ux);
endpoint_btn.addEventListener('click', () => visit(endpoint));
delete_all_fields_btn.addEventListener('click', () => {
	delete_fields();
	update_ux();
});
edit_profile_btn.addEventListener('click', e => {
	let p = parse_profile();
	profile_ta.value = e.altKey ? Array.from(p).join(' ') : JSON.stringify(p.toJSON(true), ext_stringify, JSON_INDENT);
	profile_dialog.showModal();
});
profile_save_btn.addEventListener('click', () => {
	let text = profile_ta.value.trim();
	let p;
	try {
		if (text.startsWith('{')) {
			p = Profile.from(JSON.parse(text));
		} else {
			p = new Profile();
			for (let s of text.split(/[\s,]+/)) {
				s = s.trim();
				if (s) p.set(s);
			}
		}
	} catch (err) {
		window.alert(err);
		return;
	}
	delete_fields();
	for (let key of p.texts) {
		add_field({type: TYPE_TEXT, arg: key});
	}
	for (let key of p.datas) {
		add_field({type: TYPE_DATA, arg: key});
	}
	for (let type of p.coins) {
		let coin = Coin.fromType(type);
		add_field({type: TYPE_ADDR, arg: coin.unnamed ? coin.toJSON() : `$${coin.name}` })		
	}
	if (p.chash)  add_field({type: TYPE_CHASH});
	if (p.pubkey) add_field({type: TYPE_PUBKEY});
	if (p.name)   add_field({type: TYPE_NAME});
	if (p.addr0)  add_field({type: TYPE_ADDR});
	update_ux();
	profile_dialog.close();

});
resolve_btn.addEventListener('click', () => visit(`https://adraffy.github.io/ens-normalize.js/test/resolver.html#${parse_name().norm}`));
to_batch_btn.addEventListener('click', () => {
	load_config({
		endpoint: 'https://ccip-v2.ens.xyz',
		proto: 'raw',
		batches: [{
			endpoints: [endpoint],
			address: sender,
			calldata: make_calldata(),
		}]
	})
});
start_btn.addEventListener('click', try_call);
stop_btn.addEventListener('click', () => {
	aborter.abort();
	stop_btn.disabled = true;
});
to_calldata_btn.addEventListener('click', () => {
	endpoint_field.value = endpoint;
	if (!can_proto()) proto_select.value = 'raw';
	calldata_ta.value = make_calldata();
	func_select.value = FUNC_CALLDATA;
	update_ux();
});
make_calldata_btn.addEventListener('click', () => {
	output_div.innerHTML = '';
	try {
		start_time = Date.now();
		let row = create_log({title: 'Calldata'});
		if (func_select.value === FUNC_ABI) {
			add_tag(row, create_tag('Signature', abi_func.format(), 'code'));
			add_tag(row, create_tag('Inputs', abi_func.inputs.length));
		}
		const name = parse_name();
		if (name) {
			add_tag(row, create_tag('Normalized', name.norm, 'code'));
			add_tag(row, create_tag('Namehash', create_copy_btn(name.node), 'code'));
			add_tag(row, create_tag('DNS-Encoded', create_copy_btn(name.dns), 'code'));
		}
		output_div.append(row, create_pre(make_calldata(), true, row, Infinity));
		if (func_select.value === FUNC_ENSIP10) {
			const calls = make_getters(parse_name());
			for (let i = 0; i < calls.length; i++) {
				let call = ethers.hexlify(calls[i]);
				let row = create_log({time: `#${i+1}`});
				let {name, args: [_, arg], selector} = RESOLVE_ABI.parseTransaction({data: call});
				add_tag(row, create('span', {className: 'tag record', dataset: {name}, innerHTML: `${name}(${arg ?? ''})`}));
				output_div.append(row, create_pre(call, true, row, Infinity));
			}
		}
	} catch (err) {
		append_error(err);
	}
});
add_field_btn.addEventListener('click', e => { 
	if (e.altKey) {
		delete_fields();
		let p = Profile.ENS();
		for (let x of p.texts) add_field({type: TYPE_TEXT, arg: x});
		for (let x of p.datas) add_field({type: TYPE_DATA, arg: x});
		for (let x of p.coins) add_field({type: TYPE_ADDR, arg: `$${Coin.fromType(x).name}`});
		add_field({type: TYPE_CHASH});
		add_field({type: TYPE_PUBKEY});
		add_field({type: TYPE_NAME});
	} else {
		add_field();
	}
	update_ux(); 
});
add_batch_btn.addEventListener('click', e => {
	add_batch();
	update_ux();
});
delete_all_batches_btn.addEventListener('click', () => {
	delete_batches();
	update_ux();
});
copy_link_btn.addEventListener('click', () => {
	navigator.clipboard.writeText(window.location.href);
});
for (let f of [endpoint_field, sender_field, name_field, dns_name_field]) {
	f.addEventListener('keydown', e => {
		if (e.key === 'Enter') {
			if (aborter) {	
				stop_btn.click();
			} else {
				start_btn.click();
			}
		}
	});
}
window.addEventListener('hashchange', () => process_hash());

for (let btn of document.querySelectorAll('#examples button')) {
	btn.addEventListener('click', () => load_config(JSON.parse(btn.dataset.config)));
}

if (!process_hash(true)) {
	try {
		//load_config(JSON.parse(localStorage[STORAGE_KEY]));
		load_config(localStorage[STORAGE_KEY]);
	} catch (err) {
		update_ux();
	}
}

function process_hash(first) {
	let hash = window.location.hash.slice(1);
	//history.replaceState(null, null, ' ');
	if (hash) {
		try {
			load_config(config_from_params(new URLSearchParams(hash)));
			//load_config(JSON.parse(atob(hash)));
			if (update_ux() && first) {
				setTimeout(() => start_btn.click(), 50);
			}
			return true;
		} catch (err) {
			console.error(err);
		}
	}
}

function config_from_params(params) {
	let json = {};
	for (let [k, v] of params) {
		if (k === 'field') {
			if (!json.fields) json.fields = [];
			let pos = v.indexOf('-');
			if (pos >= 0) {
				k = v.slice(0, pos);
				v = v.slice(pos + 1);
			} else {
				k = v;
				v = '';
			}
			switch (k) {
				case TYPE_TEXT:
				case TYPE_DATA:
				case TYPE_ADDR:
					json.fields.push({type: k, arg: v});
					break;
				case TYPE_CHASH:
				case TYPE_PUBKEY:
				case TYPE_NAME:
					json.fields.push({type: k});
					break;
				default:
					break;
			}
		} else if (k === 'batch') {
			if (!json.batches) json.batches = [];
			let [hex, ...endpoints] = v.split(',');
			if (!ethers.isHexString(hex) || hex.length < 50) { // 2 + 40 + 8
				continue;
			}
			json.batches.push({
				address: hex.slice(0, 42),
				calldata: '0x' + hex.slice(42),
				endpoints
			});
		} else if (k === 'arg') {
			if (!json.args) json.args = [];
			json.args.push(v);
		} else {
			json[k] = v;
		}
	}
	return json;
}
function params_from_config(json) {
	let params = new URLSearchParams();
	for (let [k, v] of Object.entries(json)) {
		if (k === 'fields') {
			v.forEach(({type, arg}) => params.append('field', type_has_arg(type) ? `${type}-${arg}` : type));
		} else if (k === 'batches') {
			v.forEach(({address, calldata, endpoints}) => params.append('batch', [`${address}${calldata.slice(2)}`, ...endpoints].join(',')));
		} else if (k === 'args') {
			v.forEach(x => params.append('arg', x));
		} else if (k === 'proto' && (!can_proto() || v === DEFAULT_PROTO)) {
			continue;
		} else if (v) {
			params.append(k, v);
		}
	}
	if (func_select.value !== FUNC_ENSIP10 && detect_type(config_from_params(params)) !== func_select.value) {
		params.append('type', func_select.value);
	}
	return params;
}

function detect_type(json) {
	switch (json.type) {
		case FUNC_ABI:
		case FUNC_BATCH:
		case FUNC_CALLDATA:
		case FUNC_DNS:
		case FUNC_URG: return json.type;
	}
	if (typeof json.dns === 'string') return FUNC_DNS;
	if (typeof json.abi === 'string') return FUNC_ABI;
	if (typeof json.calldata === 'string') return FUNC_CALLDATA;
	if (Array.isArray(json.batches)) return FUNC_BATCH;
	if (typeof json.request === 'string') return FUNC_URG;
	return FUNC_ENSIP10;
}

function load_config(json) {
	endpoint_field.value = json.endpoint || '';
	sender_field.value = json.sender || '';
	proto_select.value = json.proto || DEFAULT_PROTO;
	const type = detect_type(json);
	func_select.value = type;
	if (type === FUNC_ABI) {
		abi_ta.value = json.abi || '';
		parse_abi();
		if (abi_func && Array.isArray(json.args)) {
			abi_func.inputs.forEach((_, i) => {
				abi_fields[i].querySelector('input').value = json.args[i] || '';
			});
		}
	} else if (type === FUNC_CALLDATA) {
		calldata_ta.value = json.calldata || '';
	} else if (type === FUNC_BATCH) {
		delete_batches();
		json.batches?.forEach(add_batch);
	} else if (type === FUNC_URG) {
		urg_ta.value = json.request || '';
	} else if (type === FUNC_DNS) {
		dns_name_field.value = json.dns || '';
	} else {
		func_select.value = FUNC_ENSIP10;
		name_field.value = json.name || '';
		multi_select.value = json.multi;
		node_as_null_check.checked = !!json.null;
		if (!multi_select.value) multi_select.selectedIndex = 0;
		delete_fields();
		if (Array.isArray(json.fields)) {
			for (let {type, arg} of json.fields) {
				add_field({type, arg});
			}
		}
	}
	update_ux();
	focus_func();
}
function focus_func() {
	requestAnimationFrame(() => {
		switch (func_select.value) {
			case FUNC_ENSIP10: name_field.focus(); break;
			case FUNC_ABI: abi_ta.focus(); break;
			case FUNC_CALLDATA: calldata_ta.focus(); break;
			case FUNC_BATCH: batch_div.querySelector('.addr_field')?.focus(); break;
			case FUNC_URG: urg_context_field.focus(); break;
			case FUNC_DNS: dns_name_field.focus(); break;
		}
	});
}

function parse_endpoint(endpoint0 = '') {
	endpoint_field.placeholder = endpoint0 || 'https://raffy.xyz/tog/{data}';
	try {
		endpoint = endpoint_field.value.trim() || endpoint0;
		new URL(endpoint.replaceAll(TEMPLATE_SENDER, '0x').replaceAll(TEMPLATE_DATA, '0x'));
		method_span.innerHTML = endpoint.includes(TEMPLATE_DATA) ? 'GET' : 'POST';
		endpoint_status.innerHTML = '';
	} catch (err) {
		endpoint = undefined;
		method_span.innerHTML = '';
		endpoint_status.innerHTML = 'Invalid URL';
	}
	endpoint_btn.disabled = !endpoint;
}
function parse_sender() {
	try {
		sender = sender_field.value.trim();
		sender = sender ? ethers.getAddress(sender) : ethers.ZeroAddress;
		sender_status.innerHTML = '';
	} catch (err) {
		sender = undefined;
		sender_status.innerHTML = err.shortMessage || err.message;
	}
}
function parse_calldata() {
	calldata_btn.disabled = true;
	try {
		let hex = calldata_ta.value.trim();
		if (!/^(0x)[0-9a-f]*$/i.test(hex)) throw new Error('expected 0x-prefixed hex string');
		if (hex.length < 10) throw new Error('expected bytes4 selector');
		calldata_btn.disabled = false;
		if ((hex.length - 10) % 64) throw new Error('expected 32-byte padding');
		calldata_status.innerHTML = '';
		return hex;
	} catch (err) {
		calldata_status.innerHTML = err.message;
	}
}
function parse_abi() {
	try {
		abi = new ethers.Interface(abi_ta.value.split('\n').map(s => s.trim()).filter(x => x));
		let funcs = abi.fragments.filter(f => ethers.Fragment.isFunction(f));
		if (!funcs.length) throw new Error('expected function');
		if (funcs.length != 1) throw new Error('expected one function');
		abi_func = funcs[0];
		abi_span.innerText = abi_func.selector;
		abi_status.innerText = '';
	} catch (err) {
		abi = undefined;
		abi_func = undefined;
		abi_span.innerText = '';
		abi_status.innerText = err.shortMessage || err.message;
		abi_fields.forEach(x => x.classList.add('hide'));
		return;
	}
	const n = abi_func.inputs.length;
	for (let i = n; i < abi_fields.length; i++) {
		abi_fields[i].classList.add('hide');
	}
	for (let i = 0; i < n; i++) {
		let row = abi_fields[i];
		if (!row) {
			row = create('div', {className: 'wide field'});
			let name = `#abi_${i}`;
			row.append(create('label', {for: name}, 
				create('span', {className: 'name'}),
				create('span', {className: 'type'}),
			));
			let input_field = create('input', {
				name,
				input() {
					update_ux_soon();
				}
			});
			let coder_select = create('select', {
				className: 'suggest_select',
				input() {
					let op = BYTES_OPS[coder_select.selectedIndex];
					coder_select.selectedIndex = -1;
					if (!op) return;
					input_field.value = op.encode(input_field.value.trim());
					update_ux();
				}
			});
			for (let op of BYTES_OPS) {
				coder_select.append(create('option', null, op.name));
			}
			coder_select.selectedIndex = -1;
			row.append(input_field, coder_select);
			abi_fields[i] = row;
			abi_div.append(row);
		}
		let param = abi_func.inputs[i];
		row.classList.remove('hide');
		row.querySelector('.name').innerText = param.name;
		row.querySelector('.type').innerText = param.type;
		row.querySelector('.suggest_select').classList.toggle('hide', param.type === 'string');
	}
}
function parse_name() {
	let field, status;
	switch (func_select.value) {
		case FUNC_DNS: {
			field = dns_name_field;
			status = dns_name_status;
			break;
		}
		case FUNC_ENSIP10: {
			field = name_field;
			status = name_status;
			break;
		}
		default: return;
	}
	const input = field.value.trim();
	try {
		if (!input) throw new Error('empty name');
		const norm = ethers.ensNormalize(input);
		const dns = ethers.hexlify(dns_encoded(norm));
		const node = ethers.namehash(norm);
		status.innerHTML = '';
		return {input, norm, node, dns};
	} catch (err) {
		let message = err.shortMessage || err.message;
		const match = message.match(/^invalid ENS name \((.*)\)$/);
		if (match) message = match[1];
		status.innerHTML = message;
		return {input, message};
	}
}

function parse_type(param, input) {
	// TODO: make this less shit
	switch (param.type) {
		case 'boolean': return parse_as_json(input, 'boolean');
		case 'string':  return parse_as_json(input, 'string');
		case 'bytes': return ethers.hexlify(input);
	}
	let match;
	if (match = param.type.match(/^bytes(\d+)$/)) {
		return ethers.zeroPadBytes(input, parseInt(match[1]));
	}
	if (param.type.startsWith('uint')) {
		return BigInt(input);
	}
}
function parse_as_json(input, type, test) {
	try {
		let value = JSON.parse(input);
		if (test ? test(value) : typeof value === type) {
			return value;
		}
	} catch (err) {	
	}
	throw new Error(`expected ${type}: "${input}"`);
}

function update_ux_soon() {
	if (update_timer) return;
	update_timer = setTimeout(update_ux, 100);
}
function update_ux() {
	clearTimeout(update_timer);
	update_timer = false;

	const func = func_select.value;
	ensip10_div.classList.toggle('hide',  func !== FUNC_ENSIP10);
	abi_div.classList.toggle('hide',      func !== FUNC_ABI);
	calldata_div.classList.toggle('hide', func !== FUNC_CALLDATA);
	batch_div.classList.toggle('hide',    func !== FUNC_BATCH);
	urg_div.classList.toggle('hide',      func !== FUNC_URG);
	dns_div.classList.toggle('hide',      func !== FUNC_DNS);

	to_calldata_btn.classList.toggle('hide', func == FUNC_CALLDATA);
	make_calldata_btn.classList.toggle('hide', func == FUNC_CALLDATA);

	let ok = true;
	
	let json = {
		endpoint: endpoint_field.value,
		sender: sender_field.value,
	};

	if (can_proto(func)) {
		json.proto = proto_select.value;
	}

	let show_unknown = false;
	let endpoint0;
	if (func === FUNC_ABI) {
		parse_abi();
		if (!abi) ok = false;
		json.abi = abi_ta.value;
		if (abi_func) {
			json.args = Array.from(abi_func.inputs, (_, i) => abi_fields[i].querySelector('input').value);	
		}
	} else if (func === FUNC_CALLDATA) {
		if (!parse_calldata()) ok = false;
		json.calldata = calldata_ta.value;
	} else if (func === FUNC_BATCH) {
		if (!get_batches().length) add_batch();
		let batches = get_batches().map(parse_batch);
		delete_all_batches_btn.classList.toggle('hide', batches.length < 2);
		if (batches.some(x => x.error)) ok = false;
		json.batches = batches;
		endpoint0 = 'https://ccip-v3.ens.xyz';
	} else if (func === FUNC_URG) {
		//urg_verifier_btn.disabled = !urg_verifier_field.value.trim();
		if (!parse_urg_context()) ok = false;
		if (!ethers.isHexString(urg_ta.value.trim())) ok = false;
		json.context = urg_context_field.value;
		json.request = urg_ta.value;
	} else if (func === FUNC_DNS) {
		const name = parse_name();
		if (!name.norm) ok = false;
		json.dns = name.input;
		endpoint0 = 'https://dnssec-oracle.ens.domains/';
	} else {
		let fields = get_fields().map(parse_field);
		if (!fields.length) show_unknown = true;
		field_count_lbl.innerHTML = `${fields.length} ${plural(fields.length, 'field')}`;
		delete_all_fields_btn.classList.toggle('hide', fields.length < 2);
		multi_select.classList.toggle('hide', fields.length < 2);
		//if (!fields.length) ok = false;
		const name = parse_name();
		if (!name.norm) ok = false;
		json.name = name.input;
		resolve_btn.disabled = !name;
		if (fields.some(x => x.error)) ok = false;
		if (fields.length >= 2) {
			json.multi = multi_select.value;
		}
		json.fields = fields;
		to_batch_btn.disabled = !ok;
		if (node_as_null_check.checked) json.null = 1;
	}
	proto_div.classList.toggle('hide', !can_proto(func));
	start_btn.classList.toggle('unsupported', show_unknown);

	make_calldata_btn.disabled = !ok;
	to_calldata_btn.disabled = !ok;
	parse_endpoint(endpoint0);
	if (!endpoint) ok = false;
	parse_sender();
	if (!sender) ok = false;
	start_btn.disabled = !ok;

	localStorage[STORAGE_KEY] = JSON.stringify(json);

	let query = params_from_config(json).toString();
	history.replaceState(null, null, query ? '#' + query : ' ');

	if (!aborter) {
		output_div.innerHTML = '';
	}

	return ok;
}

function can_proto(func = func_select.value) {
	switch (func) {
		case FUNC_ABI:
		case FUNC_CALLDATA:
		case FUNC_ENSIP10: return true;
		default: return false;
	}
}

function make_getters(name) {
	return parse_profile().makeGetters(node_as_null_check.checked ? {node: ethers.ZeroHash} : {name: name.norm});
}

function make_calldata() {
	if (func_select.value === FUNC_ABI) {
		return abi.encodeFunctionData(abi_func, abi_func.inputs.map((param, i) => {
			return parse_type(param, abi_fields[i].querySelector('input').value.trim());
		}));
	} else if (func_select.value === FUNC_URG) {
		return URG_ABI.encodeFunctionData('proveRequest', [parse_urg_context(), [urg_ta.value]]);
	} else if (func_select.value === FUNC_DNS) {
		return DNS_ABI.encodeFunctionData('resolve', [parse_name().dns, 16]);
	} else if (func_select.value === FUNC_CALLDATA) {
		return calldata_ta.value.trim();
	} else if (func_select.value === FUNC_BATCH) {
		let batches = get_batches().map(parse_batch);
		return BATCH_ABI.encodeFunctionData('query', [batches.map(x => [x.address, x.endpoints, x.calldata])]);
	} else {
		const name = parse_name();
		const calls = make_getters(name);
		if (!calls.length) {
			return RESOLVE_ABI.encodeFunctionData('resolve', [name.dns, '0x12345678']);
		} else if (calls.length == 1) {
			return RESOLVE_ABI.encodeFunctionData('resolve', [name.dns, calls[0]]);
		} else if (multi_select.value == 'outer') {
			return RESOLVE_ABI.encodeFunctionData('multicall', [calls.map(call => RESOLVE_ABI.encodeFunctionData('resolve', [name.dns, call]))]);
		} else {
			return RESOLVE_ABI.encodeFunctionData('resolve', [name.dns, RESOLVE_ABI.encodeFunctionData('multicall', [calls])]);
		}
	}
}

function set_working(b) {
	main_spinner.classList.toggle('hide', !b);
	start_btn.classList.toggle('hide', b);
	make_calldata_btn.classList.toggle('hide', b);
	stop_btn.classList.toggle('hide', !b);
	proto_select.disabled = b;
	func_select.disabled = b;	
}

async function try_call() {
	start_time = Date.now();
	aborter = new AbortController();
	output_div.innerHTML = '';
	stop_btn.disabled = false;
	set_working(true);
	//let signer = signer_field.value.trim();
	try {
		let request = make_calldata();
		let url = endpoint.replaceAll(TEMPLATE_SENDER, sender).replaceAll(TEMPLATE_DATA, request);
		let options = {
			method: 'GET',
			signal: aborter.signal,
			cache: 'no-store'
		};
		let post = url === endpoint;
		if (post) {
			options.method = 'POST';
			options.headers = {'content-type': 'application/json'};
			options.body = JSON.stringify({sender, data: request});
		}
		let row0 = create_log({title: '‚¨ÜÔ∏è Client Request'});
		add_tag(row0, create_tag('HTTP Method', options.method, 'http'));
		output_div.append(row0);
		if (post) {
			add_tag(row0, create_tag('URL', url));
			output_div.append(create_pre(options.body, false, row0));
		} else {
			output_div.append(create_pre(url, false, row0));
		}
		
		let request_hash = ethers.keccak256(request);
		let row1 = create_log({title: 'üìúÔ∏è Request Data'});
		add_tag(row1, create_tag('Sender', sender, 'code addr'));
		add_tag(row1, create_tag('Hash', request_hash, 'code hash'));
		output_div.append(row1, create_pre(request, true, row1));

		let res = await fetch(url, options);
		let text = await res.text();

		let row2 = create_log({title: '‚¨áÔ∏è Server Response'});
		row2.classList.add(status_class(res.ok));
		add_tag(row2, create_tag('HTTP Status', res.status, 'http'));
		add_tag(row2, create_tag('Content Type', res.headers.get('content-type')));
		output_div.append(row2, create_pre(text, false, row2));

		let json = JSON.parse(text);
		let {data: response, message = 'no "message" specified', ...rest} = json;
		//rest.a = 'a';
		let unknown = Object.keys(rest);
		if (unknown.length) {
			let row = create_log({title: 'Unexpected Response Keys'});
			row.classList.add('error');
			add_tag(row, create_tag('Count', unknown.length));
			output_div.append(row, create_pre(unknown.join(', '), false, row));
		}
		if (res.ok) {
			if (response) {
				add_tag(row2, create_tag('Data Payload', create_copy_btn(response)));
			}
			const proto = can_proto() ? proto_select.value : 'raw';
			if (proto === 'tor') {
				let [sig, exp, signed_response] = ABI_CODER.decode(['bytes', 'uint64', 'bytes'], response);
				let signed_response_hash = ethers.keccak256(signed_response);
				let hash = ethers.solidityPackedKeccak256(
					['address', 'uint64', 'bytes32', 'bytes32'],
					[sender, exp, request_hash, signed_response_hash]
				);
				create_proto_row({kind: 'TOR', hash, sig, exp});
				let signed = ethers.recoverAddress(hash, sig);
				create_signed_row({signed, signed_response, signed_response_hash});
				response = signed_response;
			} else if (proto === 'ens') {
				let [signed_response, exp, sig] = ABI_CODER.decode(['bytes', 'uint64', 'bytes'], response);
				let signed_response_hash = ethers.keccak256(signed_response);
				let hash = ethers.solidityPackedKeccak256(
					['bytes', 'address', 'uint64', 'bytes32', 'bytes32'], 
					['0x1900', sender, exp, request_hash, signed_response_hash]
				);
				create_proto_row({kind: 'ENS', hash, sig, exp});
				let signed = ethers.recoverAddress(hash, sig);
				create_signed_row({signed, signed_response, signed_response_hash});
				response = signed_response;
			} else {
				let row = create_log({title: 'üîìÔ∏è Unsigned Response Data'});
				output_div.append(row);
				create_pre(response, true, row, 0); // dont append
			}

			if (func_select.value === FUNC_ENSIP10) {
				let parsed = RESOLVE_ABI.parseTransaction({data: request});
				let calls, answers;
				let multicall = RESOLVE_ABI.getFunction('multicall');
				if ((response.length - 2) & 63) {
					const row = create_log({title: '‚ö†Ô∏è Resolver Error'});
					row.classList.add('error');
					const selector = response.slice(0, 10);
					add_tag(row, create_tag('Error', [
						create('a', {href: `https://www.4byte.directory/signatures/?bytes4_signature=${selector}`}, selector), 
						create_copy_btn(selector)
					], 'code selector'));
					const error = RESOLVE_ABI.parseError(response);
					if (error) {
						add_tag(row, create_tag('Signature', error.signature, 'code'));
					}
					add_tag(row, create_copy_btn(response));
					output_div.append(row, create_pre(response));
				} else {
					if (parsed.name === 'resolve') {
						let call = parsed.args[1];
						if (call.startsWith(multicall.selector)) {
							[calls] = RESOLVE_ABI.decodeFunctionData(multicall, call);
							[answers] = RESOLVE_ABI.decodeFunctionResult(multicall, response);
						} else {
							calls = [call];
							answers = [response];
						}
					} else {
						calls = parsed.args[0].toArray().map(call => RESOLVE_ABI.decodeFunctionData('resolve', call)[1]);
						[answers] = RESOLVE_ABI.decodeFunctionResult(multicall, response);
					}
					calls.forEach((call, i) => {
						let answer = answers[i];
						const isError = ((answer.length - 2) & 63) != 0;
						let {name, args: [_, arg], selector} = RESOLVE_ABI.parseTransaction({data: call});
						let row = create_log({time: `#${i+1}`});
						add_tag(row, create('span', {className: 'tag record', dataset: {name}, innerHTML: `${name}(${arg ?? ''})`}));
						add_tag(row, create_tag('Request', [call.slice(0, 10), create_copy_btn(call)], 'code selector'));
						row.classList.toggle('error', isError);
						if (isError) {
							const selector = answer.slice(0, 10);
							add_tag(row, create_tag('Error', [
								create('a', {href: `https://www.4byte.directory/signatures/?bytes4_signature=${selector}`}, selector), 
								create_copy_btn(selector)
							], 'code selector'));
							const error = RESOLVE_ABI.parseError(answer);
							if (error) {
								add_tag(row, create_tag('Signature', error.signature, 'code'));
							}
						}
						add_tag(row, create_tag('Response', create_copy_btn(answer)));
						add_tag(row, create_tag(null, `${(answer.length - 2) >> 1} bytes`, 'size'));
						output_div.append(row);
					});

					let record = new Record();
					record.parseCalls(calls, answers);
					let row = create_log({title: 'Record'});
					add_tag(row, create_tag('Count', `${record.size}/${calls.length}`));
					add_tag(row, create_copy_btn(JSON.stringify(record.toJSON())));
					output_div.append(row, create_pre_json(record.toObject()));
				}

			} else if (func_select.value === FUNC_ABI) {
				try {
					let res = abi.decodeFunctionResult(abi_func, response);
					let m = abi_func.outputs.map((type, i) => {
						return [type.name || `[${i}]`, res[i]];
					});
					let json = Object.fromEntries(m);
					let row = create_log({title: 'üî¨Ô∏è ABI Decoded Response'});
					add_tag(row, create_tag('Outputs', m.length));
					add_tag(row, create_copy_btn(JSON.stringify(json, ext_stringify)));
					output_div.append(row, create_pre_json(json));
				} catch (err) {
					append_error(err, 'ABI Decode Error');
				}
			} else if (func_select.value === FUNC_BATCH) {
				try {
					let [failures, responses] = BATCH_ABI.decodeFunctionResult('query', response);
					let batches = get_batches().map(parse_batch);
					if (batches.length != responses.length) throw new Error('response mismatch');
					batches.forEach(({address, calldata, endpoints}, i) => {
						let row = create_log({time: `#${i+1}`});
						let fail = failures[i];
						row.classList.add(status_class(!fail));
						add_tag(row, create_tag('Address', create('a', {href: `https://etherscan.io/address/${address}`, innerText: address}), 'code addr'));
						add_tag(row, create_tag('Request', [calldata.slice(0, 10), create_copy_btn(calldata)], 'code selector'));
						let answer = responses[i];
						output_div.append(row);
						if (fail) {
							let desc = BATCH_ABI.parseError(answer);
							if (desc) {
								let {fragment, ...rest} = desc;
								if (desc.name === 'HttpError') {
									rest.args = rest.args[0].map(([code, message], i) => {
										return {code, message, endpoint: endpoints[i]};
									});
								}
								add_tag(row, create_tag('Response', create_copy_btn(answer)));
								output_div.append(create_pre_json(rest));
								answer = false;
							}
						}
						if (answer) {
							add_tag(row, create_copy_btn(answer));
							output_div.append(create_pre(answer));
						}
					});
				} catch (err) {
					append_error(err, 'ABI Decode Error');
				}
			} else if (func_select.value === FUNC_DNS) {
				const DNS_TYPES = {
					16: 'TXT',
					43: 'DS',
					48: 'DNSKEY'
				};
				try {
					let [rrs] = DNS_ABI.decodeFunctionResult('resolve', response);
					if (rrs.length == 1 && rrs[0][0] === '0x') rrs = [];
					const row0 = create_log({title: 'üî¨Ô∏è ABI Decoded Response'});
					add_tag(row0, create_tag('RRsets', rrs.length));
					output_div.append(row0);
					rrs.forEach(([rrset, sig], i) => {
						const row = create_log({time: `RRset #${i+1}`});
						output_div.append(row);
						try {
							const v = ethers.getBytes(rrset);
							const dv = new DataView(v.buffer, v.byteOffset, v.byteLength);
							let pos = 0;
							const rrtype = dv.getUint16(pos); pos += 2;
							const algorithm = v[pos++];
							const labelCount = v[pos++];
							const rrttl = dv.getUint32(pos); pos += 4;
							const expiration = dv.getUint32(pos); pos += 4;
							const inception = dv.getUint32(pos); pos += 4;
							const keytag = dv.getUint16(pos); pos += 2;
							let signerName;
							[signerName, pos] = read_rr_chunks(v, pos);
							add_tag(row, create('span', {className: 'tag dns', innerText: signerName || "<root>"}));
							let typeName = DNS_TYPES[rrtype];
							const typeTag = create_tag("Type", typeName ? `${typeName} (${rrtype})` : rrtype);
							add_tag(row, typeTag);
							add_tag(row, create_tag("Algorithm", algorithm));
							add_tag(row, create_tag("TTL", format_dur(rrttl)));
							add_tag(row, create_tag("Inception", new Date(inception * 1000).toLocaleDateString()));
							add_tag(row, create_tag("Expires", new Date(expiration * 1000).toLocaleDateString()));
							add_tag(row, create_tag("Keytag", keytag));
							const records = [];
							while (pos < v.length) {
								let name;
								[name, pos] = read_rr_chunks(v, pos);
								const type = dv.getUint16(pos); pos += 2;
								const cls = dv.getUint16(pos); pos += 2;
								let ttl = dv.getUint32(pos); pos += 4;
								const size = dv.getUint16(pos); pos += 2;
								const data = v.subarray(pos, pos += size);
								const info = {};
								records.push(info);
								if (cls !== 1) info.class = cls;
								if (name !== signerName) info.name = name;
								if (ttl !== rrttl) info.ttl = ttl;
								if (type !== rrtype) info.type = type;
								if (cls === 1 && type === 16) {
									typeTag.classList.add('http');
									[info.txt] = read_rr_chunks(data, 0, '');
								} else {
									info.data = ethers.hexlify(data);
								}
							}
							output_div.append(create_pre_json(records));
						} catch (err) {
							row.classList.add(status_class(false));
							append_error(err);
						}
						add_tag(row, create_tag('RRset', create_copy_btn(rrset)));
						add_tag(row, create_tag('Signature', create_copy_btn(sig)));
					});
				} catch (err) {
					append_error(err, 'ABI Decode Error');
				}
			}
		} else {
			append_error(message, 'CCIP-Read Error');
		}
	} catch (err) {
		append_error(err);
	}
	let row = create_log();
	add_tag(row, create_tag('Duration', `${((Date.now() - start_time)/1000).toFixed(2)} sec`));
	output_div.append(row);
	set_working(false);
	aborter = null;
}

function read_rr_chunks(v, off, sep = '.') {
	const labels = [];
	while (true) {
		const n = v[off++];
		if (!n) break;
		labels.push(ethers.toUtf8String(v.subarray(off, off += n)));
	}
	return [labels.join(sep), off];
}

function create_proto_row({kind, hash, sig, exp}) {
	let row = create_log({title: `üîóÔ∏è ${kind} Protocol`});
	add_tag(row, create_exp(exp));
	add_tag(row, create_sig_style(sig));
	add_tag(row, create_tag('Signature', sig, 'code'));
	add_tag(row, create_tag('Hash', hash, 'code hash'));
	output_div.append(row);
}
function create_signed_row({signed, signed_response, signed_response_hash}) {
	let row = create_log({title: 'üîèÔ∏è Signed Response Data'});
	add_tag(row, create_tag('Recovered Signer', signed, 'code addr'));
	add_tag(row, create_tag('Hash', signed_response_hash, 'code hash'));
	output_div.append(row, create_pre(signed_response, true, row));
}

function status_class(ok) {
	return ok ? 'success' : 'error';
}

function get_batches() {
	return [...batch_div.querySelectorAll('.field')];
}
function delete_batches() {
	get_batches().forEach(x => x.remove());
}
function add_batch({address = '', calldata = '', endpoints = []} = {}) {
	let row = create('div', {className: 'wide field'});
	let addr_field = create('input', {
		className: 'addr_field code', 
		value: address,
		placeholder: 'Contract Address', 
		input() {
			update_ux_soon();
		}
	});
	let endpoints_field = create('input', {
		className: 'endpoints_field', 
		placeholder: 'Endpoint(s)',
		value: endpoints.join(', '),
		input() {
			update_ux_soon();
		}
	});
	let calldata_ta = create('textarea', {
		className: 'calldata_ta',
		rows: 6,
		placeholder: '0x12345678...',
		input() {
			update_ux_soon();
		}
	}, calldata);
	let delete_btn = create('button', {
		className: 'delete_btn icon',
		click() {
			row.remove();
			update_ux();
		}
	}, delete_all_batches_btn.querySelector('svg').cloneNode(true));
	row.append(delete_btn, addr_field, endpoints_field, calldata_ta);
	batch_div.append(row);
	Object.assign(row, {
		addr_field,
		endpoints_field,
		calldata_ta,
	});
}
function parse_batch(row) {
	let address = row.addr_field.value.trim();
	let endpoints = row.endpoints_field.value.split(',').map(x => x.trim()).filter(x => x);
	let calldata = row.calldata_ta.value.trim();
	let error;
	try {
		address = ethers.getAddress(address);
		if (!ethers.isHexString(calldata) || calldata.length < 10) throw new Error('expected calldata');
		if (!endpoints.length) throw new Error('no endpoints');
	} catch (err) {
		error = true;
	}
	return {address, endpoints, calldata, error};
}

function delete_fields() {
	get_fields().forEach(x => x.remove());
}
function get_fields() {
	return [...ensip10_div.querySelectorAll('.field')];
}
function add_field({type, arg} = {}) {
	let row = create('div', {className: 'wide field'});
	let type_select = create('select', {
		className: 'type_select',
		input() {
			update_ux();
		}
	});
	type_select.append(create('option', {value: TYPE_TEXT}, 'text(key)'));
	type_select.append(create('option', {value: TYPE_DATA}, 'data(key)'));
	type_select.append(create('option', {value: TYPE_ADDR}, 'addr(coin?)'));
	type_select.append(create('option', {value: TYPE_CHASH}, 'contenthash()'));
	type_select.append(create('option', {value: TYPE_PUBKEY}, 'pubkey()'));
	type_select.append(create('option', {value: TYPE_NAME}, 'name()'));
	let arg_field = create('input', {
		className: 'arg_field',
		input() {
			update_ux_soon();
		}	
	});
	let delete_btn = create('button', {
		className: 'delete_btn icon',
		click() {
			row.remove();
			update_ux();
		}
	}, delete_all_fields_btn.querySelector('svg').cloneNode(true));
	let text_select = create('select', {
		className: 'suggest_select',
		input() {
			arg_field.value = this.value;
			this.selectedIndex = -1;
			update_ux_soon();
		}	
	}, SUGGESTED_TEXT_KEYS.map(x => create('option', null, x)));
	// let data_select = create('select', {
	// 	className: 'suggest_select',
	// 	input() {
	// 		arg_field.value = this.value;
	// 		this.selectedIndex = -1;
	// 		update_ux_soon();
	// 	}
	// }, SUGGESTED_DATA_KEYS.map(x => create('option', null, x)));
	let addr_select = create('select', {
		className: 'suggest_select',
		input() {
			arg_field.value = this.value;
			this.selectedIndex = -1;
			update_ux_soon();
		}	
	}, SUGGESTED_COINS.map(x => {
		let {name, title, chain, type} = x;
		let desc = chain ? `Chain: ${chain}` : `Type: ${type}`;
		return create('option', {value: `$${name}`}, `[${name}] ${title} (${desc})`);
	}));
	text_select.selectedIndex = -1;
	//data_select.selectedIndex = -1;
	addr_select.selectedIndex = -1;
	if (type) type_select.value = type;
	if (arg) arg_field.value = arg;
	row.append(delete_btn, type_select, addr_select, text_select, arg_field);
	ensip10_div.append(row);
	Object.assign(row, {
		arg_field,
		type_select,
		text_select,
		addr_select,
	});
}


function type_has_arg(type) {
	switch (type) {
		case TYPE_TEXT:
		case TYPE_DATA:
		case TYPE_ADDR: return true;
	}
}

function parse_field(f) {
	const {type_select: {value: type}, arg_field, text_select, addr_select, data_select} = f;
	arg_field.classList.toggle('invis', !type_has_arg(type));
	text_select.classList.toggle('hide', type !== TYPE_TEXT);
	//data_select.classList.toggle('hide', type !== TYPE_DATA);
	addr_select.classList.toggle('hide', type !== TYPE_ADDR);
	const arg = arg_field.value.trim();
	if (type === TYPE_TEXT || type === TYPE_DATA) {
		arg_field.placeholder = 'key';
		//if (arg.startsWith('"') && arg.endsWith('"')) arg = arg.slice(1, -1);
		return {type, arg, error: !arg.length};
	} else if (type === TYPE_ADDR) {
		arg_field.placeholder = 'coinType ‚Ä¢ evm:$chain ‚Ä¢ $abbr ‚Ä¢ <empty>';
		try {
			parse_coin(arg);
			return {type, arg};
		} catch (err) {
			return {type, arg, error: true};
		}
	}
	return {type};
}

function parse_profile() {
	let profile = new Profile();
	for (let f of get_fields()) {
		let {type, arg, error} = parse_field(f);
		if (error) continue;
		switch (type) {
			case TYPE_CHASH: {
				profile.chash = true;
				break;
			}
			case TYPE_PUBKEY: {
				profile.pubkey = true;
				break;
			}
			case TYPE_NAME: {
				profile.name = true;
				break;
			}
			case TYPE_TEXT: {
				if (arg) {
					profile.setText(arg);
				}
				break;
			}
			case TYPE_DATA: {
				if (arg) {
					profile.setData(arg);
				}
				break;
			}
			case TYPE_ADDR: {
				let coin = parse_coin(arg);
				if (coin) {
					profile.setCoin(coin);
				} else {
					profile.addr0 = true;
				}
				break;
			}
		}
	}
	return profile;
}

function parse_urg_context() {
	let context = urg_context_field.value.trim();
	if (/^\d+$/.test(context)) {
		context = ABI_CODER.encode(['uint256'], [BigInt(context)]);
	}
	if (ethers.isHexString(context)) {
		return context;
	}
}

function parse_coin(s) {
	if (!s) {
		return;
	} else if (s.startsWith('$')) {
		return Coin.fromName(s.slice(1));
	} else if (/^evm:(0x)?[0-9a-f]+$/i.test(s)) {
		return Coin.fromChain(BigInt(s.slice(4)));
	} else if (/^(0x)?[0-9a-f]+$/i.test(s)) {
		return Coin.fromType(BigInt(s));
	} else {
		throw new Error(`unknown coin format: ${s}`);
	}
}

function create_exp(exp) {
	let date = new Date(Number(exp * 1000n));
	let now = Date.now();
	let delta = date - now;
	let tag;
	if (delta >= 0) {
		tag = create_tag('Expires in', format_dur(delta));
	} else {
		tag = create_tag('Expired at', date.toLocaleString());
	}
	tag.append(create_copy_btn(exp));
	return tag;
}

function create_log({title, time = true} = {}) {
	let row = create('div', {className: 'log'});
	if (time === true) time =  `${Math.round(Date.now() - start_time)} ms`;
	let tags = create('div', {className: 'tags'});
	row.append(create('span', {className: 'time', innerHTML: time}), tags);
	if (title) add_tag(row, create('span', {className: 'tag primary', innerHTML: title}));
	return row;
}
function append_error(err, title = 'Unexpected Error') {
	let row = create_log({title: `‚ö†Ô∏è ${title}`});
	row.classList.add('error');
	output_div.append(row, create_pre(err.message || err, false, row));
	if (err instanceof Error) {
		console.error(err);
	}
}
function add_tag(row, tag) {
	row.querySelector('.tags').append(tag);
}
function create_pre(data, is_hex, row, max = 1000) {
	let bytes = is_hex ? ethers.getBytes(data) : ethers.toUtf8Bytes(data);
	if (row) {
		add_tag(row, create_tag(null, `${bytes.length} bytes`, 'size'));
		add_tag(row, create_copy_btn(data));
	}
	let pre = create('pre', {innerText: data});
	if (bytes.length >= max) pre.classList.add('clipped');
	return pre;
}
function create_pre_json(json) {
	let text = JSON.stringify(json, ext_stringify, JSON_INDENT);
	return create('pre', {innerText: text});
}
function ext_stringify(_, x) {
	if (typeof x === 'bigint') {
		let i = Number(x);
		return Number.isSafeInteger(i) ? i : ethers.toBeHex(x);
	} else if (x instanceof Uint8Array) {
		return ethers.hexlify(x);
	} else if (x instanceof Set) {
		return [...x];
	}
	return x;
}
function create_tag(key, value, cls) {
	let tag = create('span', {className: ['tag', cls]});
	if (key) {
		tag.append(create('span', {className: 'key', innerText: key}));
	}
	if (value instanceof HTMLElement) {
		tag.append(value);
	} else if (Array.isArray(value)) {
		tag.append(...value);
	} else if (value === undefined) {
		tag.append(create('span', {className: 'value null', innerText: '¬´null¬ª'}));
	} else {
		tag.append(create('span', {className: 'value', innerText: String(value)}));
	}
	return tag;
}

function create_copy_btn(s) {
	return create('button', {
		className: 'copy',
		title: s,
		click() {
			const cls = 'copied';
			document.querySelectorAll(`.${cls}`).forEach(x => x.classList.remove(cls));
			navigator.clipboard.writeText(s);
			this.classList.add(cls);
			setTimeout(() => this.classList.remove(cls), 2000);
		}
	});
}

function create(el, args, ...a) {
	if (typeof el === 'string') el = document.createElement(el);
	if (args) {
		for (let [k, v] of Object.entries(args)) {
			if (!v) continue;
			if (v instanceof Function) {
				el.addEventListener(k, v);
			} else if (k === 'dataset' || k === 'style') {
				Object.assign(el[k], v);
			} else if (k === 'className') {
				for (let x of [v].flat(Infinity)) {
					if (typeof x === 'string') {
						x = x.trim();
						if (x) el.classList.add(...x.split(/\s+/));
					} else if (x) {
						Object.entries(x).forEach(([k, v]) => el.classList.toggle(k, !!v));
					}
				}
			} else {
				el[k] = v;
			}
		}
	}
	el.append(...a.flat(Infinity));
	return el;
}
function create_sig_style(sig) {
	let n = (sig.length - 1) >> 1;
	let style = 'Unknown';
	switch (n) {
		case 65: style = 'r+s+v'; break;
		case 64: style = 'r+vs'; break;
	}
	return create_tag('Signature Style', [create('b', {innerHTML: style}), format_bytes(n)], 'size');
}
function format_bytes(n) {
	return `${n} ${plural(n, 'byte')}`;
}
function visit(href) {
	create('a', {target: '_blank', href}).click();
}
function plural(n, word, s = 's') {
	return n == 1 ? word : word + s;
}
function trim_trailing_decimal_zeros(s) {
	return s.includes('.') ? s.replace(/\.?0*$/, '') : s;
}
function format_dur(t, n = 1) {
	if (t < 500) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = ' ú';
			} else {
				t /= 24;
				if (t < 365) {
					unit = '·¥Ö';
				} else {
					t /= 365;
					unit = ' è';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(n)) + unit;
}
</script>
</body>
</html>
